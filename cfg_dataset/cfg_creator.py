import iced_x86
import networkx as nx
import matplotlib.pyplot as plt
from pyvis.network import Network
import os
import glob
from tqdm import tqdm
import pandas as pd
import click

# for infile in glob.glob(os.path.join("data", '*')):
#     review_file = open(infile,'rb').read()
#     print(review_file)

# USER EDIT: Directory where the neutralized binaries are stored
DATA_DIR = "data"

# USER EDIT: Mode of script; 0 = visualize in window, 1 = save as HTML docs, 2 = save graphs w/o visualizing
VIS_MODE = 2

fullpaths = []

# for root, subdir, files in os.walk(DATA_DIR):
#     for f in files:
#         fullpaths.append(f"{root}\\{f}")

def process_binaries(binary_paths):
    cfgs = {}
    for path in binary_paths:
        cfgs[path] = analyze_binary(path)
    return cfgs

def visualize_cfg(cfg, title):
    pos = nx.spring_layout(cfg)
    nx.draw(cfg, pos, with_labels=True, node_color='lightblue', node_size=500, font_size=8, arrows=True)
    nx.draw_networkx_labels(cfg, pos, {node: f"{node:x}" for node in cfg.nodes()})
    plt.title(title)
    plt.axis('off')
    plt.show()

def visualize_cfg_with_visnetwork(cfg, title):
    # Check if the graph is empty
    if len(cfg.nodes) == 0:
        print("The graph is empty!")
        return
    
    # Create a Network object from pyvis
    net = Network(height='800px', width='100%', bgcolor='#222222', font_color='white')
    
    # Convert NetworkX graph to a format pyvis can use
    for node in cfg.nodes():
        net.add_node(node, label=f"{node:x}", title=f"Node {node}")
    
    for edge in cfg.edges():
        net.add_edge(edge[0], edge[1], title=f"Edge from {edge[0]} to {edge[1]}")
    
    # Customize the network
    net.barnes_hut()
    net.show_buttons(filter_=['physics'])
    
    # Display the network in a browser view
    output_dir = os.path.join('cfg_dataset', 'out_html')
    os.makedirs(output_dir, exist_ok=True)
    net.save_graph(os.path.join(output_dir, f'{title}.html'))

def save_cfg(cfg, title):
    """
    Save the control flow graph (CFG) to an Edgelist file and node names to a separate file.
    
    Parameters:
    - cfg: NetworkX graph object representing the control flow graph
    - title: String representing the title of the files (without extension)
    """
    # Check if the graph is empty
    if len(cfg.nodes) == 0:
        print("The graph is empty!")
        return
    
    # Define directory for saving files
    output_dir = os.path.join('cfg_dataset', 'out_edgelists')
    os.makedirs(output_dir, exist_ok=True)
    
    # Define file paths
    edgelist_path = os.path.join(output_dir, f'{title}.txt')
    node_names_path = os.path.join(output_dir, f'{title}_node_names.csv')
    
    # Save Edgelist
    nx.write_edgelist(cfg, edgelist_path)
    # print(f"Edgelist saved to {edgelist_path}")
    
    # Save Node Names
    # possibly unnecessary but keeping in case necessary for downstream model
    node_names = {node: f"Node_{node}" for node in cfg.nodes}
    node_names_df = pd.DataFrame(list(node_names.items()), columns=['Node', 'Name'])
    node_names_df.to_csv(node_names_path, index=False)
    # print(f"Node names saved to {node_names_path}")

def analyze_and_save_binary(infile, vis_mode):
    binary_data = open(infile, 'rb').read()
    
    decoder = iced_x86.Decoder(64, binary_data, ip=0x1000)
    formatter = iced_x86.Formatter(iced_x86.FormatterSyntax.INTEL)
    
    instructions = list(decoder)
    cfg = nx.DiGraph()
    
    for i, instr in enumerate(instructions):
        cfg.add_node(instr.ip, instruction=formatter.format(instr))
        
        if instr.flow_control in (iced_x86.FlowControl.UNCONDITIONAL_BRANCH, iced_x86.FlowControl.CONDITIONAL_BRANCH):
            if instr.op_count > 0 and instr.op0_kind in (
                iced_x86.OpKind.IMMEDIATE8, 
                iced_x86.OpKind.IMMEDIATE16, 
                iced_x86.OpKind.IMMEDIATE32, 
                iced_x86.OpKind.IMMEDIATE64
            ):
                target = instr.immediate
                cfg.add_edge(instr.ip, target)
            
            if instr.flow_control == iced_x86.FlowControl.CONDITIONAL_BRANCH:
                next_ip = instructions[i+1].ip if i+1 < len(instructions) else None
                if next_ip:
                    cfg.add_edge(instr.ip, next_ip)
    
    f_id = os.path.basename(infile)
    
    if vis_mode == 0:
        visualize_cfg(cfg, f"CFG for {infile}")
    elif vis_mode == 1:
        visualize_cfg_with_visnetwork(cfg, f"{f_id}-")
    elif vis_mode == 2:
        save_cfg(cfg, f"{f_id}")
    else:
        raise ValueError(f"Invalid Visualization Mode {vis_mode}")

@click.command()
@click.option('--data_dir', default='data', help='Directory where the neutralized binaries are stored')
@click.option('--vis_mode', default=2, type=int, help='Visualization mode: 0 = visualize in window, 1 = save as HTML docs, 2 = save graphs w/o visualizing as edgelists')
def main(data_dir, vis_mode):
    for infile in tqdm(glob.glob(os.path.join(data_dir, '*')), desc="Processing binaries"):
        analyze_and_save_binary(infile, vis_mode)

if __name__ == '__main__':
    main()
