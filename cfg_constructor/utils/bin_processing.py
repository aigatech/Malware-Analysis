from utils.log_utils import (setup_logging, log_visualization, is_already_visualized)
from utils.vis_utils import vis

import iced_x86
import os
import networkx as nx

def process_binaries(binary_paths):
    cfgs = {}
    for path in binary_paths:
        cfgs[path] = analyze_binary(path)
    return cfgs

def analyze_and_save_binary(infile, vis_mode, log_file):
    if is_already_visualized(log_file, infile):
        print(f"Skipping {infile} as it has already been visualized.")
        return 
        
    binary_data = open(infile, 'rb').read()
    
    decoder = iced_x86.Decoder(64, binary_data, ip=0x1000)
    formatter = iced_x86.Formatter(iced_x86.FormatterSyntax.INTEL)
    
    instructions = list(decoder)
    cfg = nx.DiGraph()
    
    for i, instr in enumerate(instructions):
        cfg.add_node(instr.ip, instruction=formatter.format(instr))
        
        if instr.flow_control in (iced_x86.FlowControl.UNCONDITIONAL_BRANCH, iced_x86.FlowControl.CONDITIONAL_BRANCH):
            if instr.op_count > 0 and instr.op0_kind in (
                iced_x86.OpKind.IMMEDIATE8, 
                iced_x86.OpKind.IMMEDIATE16, 
                iced_x86.OpKind.IMMEDIATE32, 
                iced_x86.OpKind.IMMEDIATE64
            ):
                target = instr.immediate
                cfg.add_edge(instr.ip, target)
            
            if instr.flow_control == iced_x86.FlowControl.CONDITIONAL_BRANCH:
                next_ip = instructions[i+1].ip if i+1 < len(instructions) else None
                if next_ip:
                    cfg.add_edge(instr.ip, next_ip)
    
    # visualization wrapper
    vis(cfg, infile, vis_mode)

    # if at this point, then visualization was successful - log
    log_visualization(log_file, infile, vis_mode)

    del decoder
    del cfg
    del formatter
    del instructions
    del binary_data
