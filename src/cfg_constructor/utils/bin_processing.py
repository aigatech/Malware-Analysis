from utils.log_utils import (log_visualization, is_already_visualized)
from utils.vis_utils import vis

import iced_x86
import networkx as nx

FORMATTER = iced_x86.Formatter(iced_x86.FormatterSyntax.INTEL)

OP_SET = {
    iced_x86.OpKind.IMMEDIATE8,
    iced_x86.OpKind.IMMEDIATE16,
    iced_x86.OpKind.IMMEDIATE32,
    iced_x86.OpKind.IMMEDIATE64
}

BRANCH_SET = {
    iced_x86.FlowControl.UNCONDITIONAL_BRANCH,
    iced_x86.FlowControl.CONDITIONAL_BRANCH
}

def analyze_and_save_binary(infile, vis_mode, log_file):
    """
    Analyze a binary file, generate its control flow graph (CFG), 
    visualize it, and log the visualization details.

    Parameters:
    infile (str): The path to the binary file to analyze.
    vis_mode (int): The mode of visualization to use.
    log_file (str): The path to the log file for recording visualization details.
    """
    if is_already_visualized(log_file, infile):
        return 
        
    binary_data = open(infile, 'rb').read()
    
    decoder = iced_x86.Decoder(64, binary_data, ip=0x1000)
    
    instructions = list(decoder)
    cfg = nx.DiGraph()
    
    for i, instr in enumerate(instructions):
        cfg.add_node(instr.ip, instruction=FORMATTER.format(instr))
        
        if instr.flow_control in BRANCH_SET:
            if instr.op_count > 0 and instr.op0_kind in OP_SET:
                target = instr.immediate
                cfg.add_edge(instr.ip, target)
            
            if instr.flow_control == iced_x86.FlowControl.CONDITIONAL_BRANCH:
                next_ip = instructions[i+1].ip if i+1 < len(instructions) else None
                if next_ip:
                    cfg.add_edge(instr.ip, next_ip)
    
    vis(cfg, infile, vis_mode)
    log_visualization(log_file, infile, vis_mode)